/* automatically generated by rust-bindgen 0.66.1 */

pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
pub type __vcrt_bool = bool;
pub type __crt_bool = bool;
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type _locale_t = *mut __crt_locale_pointers;
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type FILE = _iobuf;
pub type fpos_t = ::std::os::raw::c_longlong;
pub type float_t = f32;
pub type double_t = f64;
pub type __gnuc_va_list = __builtin_va_list;
pub type pGEcontext = *mut R_GE_gcontext;
#[doc = "--------- New (in 1.4.0) device driver structure ---------\n NOTES:\n 1. All locations and dimensions are in device coordinates.\n 2. I found this comment in the doc for dev_Open -- looks nasty\n    Any known instances of such a thing happening?  Should be\n    replaced by a function to query the device for preferred gpars\n    settings? (to be called when the device is initialised)\n\n NOTE that it is perfectly acceptable for this\n function to set generic graphics parameters too\n (i.e., override the generic parameter settings\n which GInit sets up) all at the author's own risk\n of course :)\n\n 3. Do we really need dev_StrWidth as well as dev_MetricInfo?\n    I can see the difference between the two -- its just a\n    question of whether dev_MetricInfo should just return\n    what dev_StrWidth would give if font metric information is\n    not available.  I guess having both allows the developer\n    to decide when to ask for which sort of value, and to decide\n    what to do when font metric information is not available.\n    And why not a dev_StrHeight?\n 4. Should \"ipr\", \"asp\", and \"cra\" be in the device description?\n    If not, then where?\n    I guess they don't need to be if no device makes use of them.\n    On the other hand, they would need to be replaced by a device\n    call that R base graphics could use to get enough information\n    to figure them out.  (e.g., some sort of dpi() function to\n    complement the size() function.)"]
pub type DevDesc = _DevDesc;
pub type pDevDesc = *mut DevDesc;
pub type GEDevDesc = _GEDevDesc;
pub type GEcallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: GEevent, arg2: *mut GEDevDesc, arg3: SEXP) -> SEXP,
>;
pub type pGEDevDesc = *mut GEDevDesc;
#[doc = "-------------------------------------------------------------------\n\n  COLOUR CODE is concerned with the internals of R colour representation\n\n  From colors.c, used in par.c, grid/src/gpar.c"]
pub type rcolor = ::std::os::raw::c_uint;
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
#[doc = "A structure containing graphical parameters\n\n This is how graphical parameters are passed from graphics systems\n to the graphics engine AND from the graphics engine to graphics\n devices.\n\n Devices are not *required* to honour graphical parameters\n (e.g., alpha transparency is going to be tough for some)"]
#[repr(C)]
pub struct R_GE_gcontext {
    #[doc = "pen colour (lines, text, borders, ...)"]
    pub col: ::std::os::raw::c_int,
    #[doc = "fill colour (for polygons, circles, rects, ...)"]
    pub fill: ::std::os::raw::c_int,
    #[doc = "Gamma correction"]
    pub gamma: f64,
    #[doc = "Line width (roughly number of pixels)"]
    pub lwd: f64,
    #[doc = "Line type (solid, dashed, dotted, ...)"]
    pub lty: ::std::os::raw::c_int,
    #[doc = "Line end"]
    pub lend: R_GE_lineend,
    #[doc = "line join"]
    pub ljoin: R_GE_linejoin,
    #[doc = "line mitre"]
    pub lmitre: f64,
    #[doc = "Character expansion (font size = fontsize*cex)"]
    pub cex: f64,
    #[doc = "Font size in points"]
    pub ps: f64,
    #[doc = "Line height (multiply by font size)"]
    pub lineheight: f64,
    #[doc = "Font face (plain, italic, bold, ...)"]
    pub fontface: ::std::os::raw::c_int,
    #[doc = "Font family"]
    pub fontfamily: [::std::os::raw::c_char; 201usize],
    #[doc = "Reference to a pattern fill"]
    pub patternFill: SEXP,
}
#[repr(C)]
pub struct _DevDesc {
    #[doc = "left raster coordinate"]
    pub left: f64,
    #[doc = "right raster coordinate"]
    pub right: f64,
    #[doc = "bottom raster coordinate"]
    pub bottom: f64,
    #[doc = "top raster coordinate"]
    pub top: f64,
    #[doc = "R only has the notion of a rectangular clipping region"]
    pub clipLeft: f64,
    pub clipRight: f64,
    pub clipBottom: f64,
    pub clipTop: f64,
    #[doc = "x character addressing offset - unused"]
    pub xCharOffset: f64,
    #[doc = "y character addressing offset"]
    pub yCharOffset: f64,
    #[doc = "1/2 interline space as frac of line height"]
    pub yLineBias: f64,
    #[doc = "Inches per raster; `[0]`=x, `[1]`=y"]
    pub ipr: [f64; 2usize],
    #[doc = "Character size in rasters; `[0]`=x, `[1]`=y"]
    pub cra: [f64; 2usize],
    #[doc = "(initial) Device Gamma Correction"]
    pub gamma: f64,
    #[doc = "Device-level clipping"]
    pub canClip: Rboolean,
    #[doc = "can the gamma factor be modified?"]
    pub canChangeGamma: Rboolean,
    #[doc = "Can do at least some horiz adjust of text\n0 = none, 1 = {0,0.5,1}, 2 = `[0,1]`"]
    pub canHAdj: ::std::os::raw::c_int,
    #[doc = "Device initial settings\n/\n/* These are things that the device must set up when it is created.\n The graphics system can modify them and track current values,"]
    pub startps: f64,
    #[doc = "sets par(\"fg\"), par(\"col\") and gpar(\"col\")"]
    pub startcol: ::std::os::raw::c_int,
    #[doc = "sets par(\"bg\") and gpar(\"fill\")"]
    pub startfill: ::std::os::raw::c_int,
    pub startlty: ::std::os::raw::c_int,
    pub startfont: ::std::os::raw::c_int,
    pub startgamma: f64,
    #[doc = "pointer to device specific parameters"]
    pub deviceSpecific: *mut ::std::os::raw::c_void,
    #[doc = "toggle for initial display list status"]
    pub displayListOn: Rboolean,
    #[doc = "can the device generate mousedown events"]
    pub canGenMouseDown: Rboolean,
    #[doc = "can the device generate mousemove events"]
    pub canGenMouseMove: Rboolean,
    #[doc = "can the device generate mouseup events"]
    pub canGenMouseUp: Rboolean,
    #[doc = "can the device generate keyboard events"]
    pub canGenKeybd: Rboolean,
    #[doc = "can the device generate idle events"]
    pub canGenIdle: Rboolean,
    #[doc = "This is set while getGraphicsEvent\nis actively looking for events"]
    pub gettingEvent: Rboolean,
    pub activate: ::std::option::Option<unsafe extern "C" fn(arg1: pDevDesc)>,
    pub circle: ::std::option::Option<
        unsafe extern "C" fn(x: f64, y: f64, r: f64, gc: pGEcontext, dd: pDevDesc),
    >,
    pub clip: ::std::option::Option<
        unsafe extern "C" fn(x0: f64, x1: f64, y0: f64, y1: f64, dd: pDevDesc),
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(dd: pDevDesc)>,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(arg1: pDevDesc)>,
    pub locator: ::std::option::Option<
        unsafe extern "C" fn(x: *mut f64, y: *mut f64, dd: pDevDesc) -> Rboolean,
    >,
    pub line: ::std::option::Option<
        unsafe extern "C" fn(x1: f64, y1: f64, x2: f64, y2: f64, gc: pGEcontext, dd: pDevDesc),
    >,
    pub metricInfo: ::std::option::Option<
        unsafe extern "C" fn(
            c: ::std::os::raw::c_int,
            gc: pGEcontext,
            ascent: *mut f64,
            descent: *mut f64,
            width: *mut f64,
            dd: pDevDesc,
        ),
    >,
    pub mode:
        ::std::option::Option<unsafe extern "C" fn(mode: ::std::os::raw::c_int, dd: pDevDesc)>,
    pub newPage: ::std::option::Option<unsafe extern "C" fn(gc: pGEcontext, dd: pDevDesc)>,
    pub polygon: ::std::option::Option<
        unsafe extern "C" fn(
            n: ::std::os::raw::c_int,
            x: *mut f64,
            y: *mut f64,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub polyline: ::std::option::Option<
        unsafe extern "C" fn(
            n: ::std::os::raw::c_int,
            x: *mut f64,
            y: *mut f64,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub rect: ::std::option::Option<
        unsafe extern "C" fn(x0: f64, y0: f64, x1: f64, y1: f64, gc: pGEcontext, dd: pDevDesc),
    >,
    pub path: ::std::option::Option<
        unsafe extern "C" fn(
            x: *mut f64,
            y: *mut f64,
            npoly: ::std::os::raw::c_int,
            nper: *mut ::std::os::raw::c_int,
            winding: Rboolean,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub raster: ::std::option::Option<
        unsafe extern "C" fn(
            raster: *mut ::std::os::raw::c_uint,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            x: f64,
            y: f64,
            width: f64,
            height: f64,
            rot: f64,
            interpolate: Rboolean,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub cap: ::std::option::Option<unsafe extern "C" fn(dd: pDevDesc) -> SEXP>,
    pub size: ::std::option::Option<
        unsafe extern "C" fn(
            left: *mut f64,
            right: *mut f64,
            bottom: *mut f64,
            top: *mut f64,
            dd: pDevDesc,
        ),
    >,
    pub strWidth: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ::std::os::raw::c_char,
            gc: pGEcontext,
            dd: pDevDesc,
        ) -> f64,
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            x: f64,
            y: f64,
            str_: *const ::std::os::raw::c_char,
            rot: f64,
            hadj: f64,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub onExit: ::std::option::Option<unsafe extern "C" fn(dd: pDevDesc)>,
    #[doc = "device_getEvent is no longer used, but the slot is kept for back\n compatibility of the structure."]
    pub getEvent: ::std::option::Option<
        unsafe extern "C" fn(arg1: SEXP, arg2: *const ::std::os::raw::c_char) -> SEXP,
    >,
    pub newFrameConfirm: ::std::option::Option<unsafe extern "C" fn(dd: pDevDesc) -> Rboolean>,
    #[doc = "and strWidthUTF8"]
    pub hasTextUTF8: Rboolean,
    pub textUTF8: ::std::option::Option<
        unsafe extern "C" fn(
            x: f64,
            y: f64,
            str_: *const ::std::os::raw::c_char,
            rot: f64,
            hadj: f64,
            gc: pGEcontext,
            dd: pDevDesc,
        ),
    >,
    pub strWidthUTF8: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ::std::os::raw::c_char,
            gc: pGEcontext,
            dd: pDevDesc,
        ) -> f64,
    >,
    pub wantSymbolUTF8: Rboolean,
    #[doc = "Is rotated text good enough to be preferable to Hershey in\ncontour labels?  Old default was FALSE."]
    pub useRotatedTextInContour: Rboolean,
    #[doc = "This is an environment holding event handlers."]
    pub eventEnv: SEXP,
    pub eventHelper:
        ::std::option::Option<unsafe extern "C" fn(dd: pDevDesc, code: ::std::os::raw::c_int)>,
    pub holdflush: ::std::option::Option<
        unsafe extern "C" fn(dd: pDevDesc, level: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    #[doc = "1 = no, 2 = yes"]
    pub haveTransparency: ::std::os::raw::c_int,
    #[doc = "1 = no, 2 = fully, 3 = semi"]
    pub haveTransparentBg: ::std::os::raw::c_int,
    #[doc = "1 = no, 2 = yes, 3 = except for missing values"]
    pub haveRaster: ::std::os::raw::c_int,
    #[doc = "1 = no, 2 = yes"]
    pub haveCapture: ::std::os::raw::c_int,
    #[doc = "1 = no, 2 = yes"]
    pub haveLocator: ::std::os::raw::c_int,
    pub setPattern:
        ::std::option::Option<unsafe extern "C" fn(pattern: SEXP, dd: pDevDesc) -> SEXP>,
    pub releasePattern: ::std::option::Option<unsafe extern "C" fn(ref_: SEXP, dd: pDevDesc)>,
    pub setClipPath:
        ::std::option::Option<unsafe extern "C" fn(path: SEXP, ref_: SEXP, dd: pDevDesc) -> SEXP>,
    pub releaseClipPath: ::std::option::Option<unsafe extern "C" fn(ref_: SEXP, dd: pDevDesc)>,
    pub setMask:
        ::std::option::Option<unsafe extern "C" fn(path: SEXP, ref_: SEXP, dd: pDevDesc) -> SEXP>,
    pub releaseMask: ::std::option::Option<unsafe extern "C" fn(ref_: SEXP, dd: pDevDesc)>,
    #[doc = "This should match R_GE_version,\n BUT it does not have to.\n It give the graphics engine a chance to work with\n graphics device packages BEFORE they update to\n changes in R_GE_version."]
    pub deviceVersion: ::std::os::raw::c_int,
    #[doc = "This can be used to OVERRIDE canClip so that graphics engine\n leaves ALL clipping to the graphics device"]
    pub deviceClip: Rboolean,
    pub defineGroup: ::std::option::Option<
        unsafe extern "C" fn(
            source: SEXP,
            op: ::std::os::raw::c_int,
            destination: SEXP,
            dd: pDevDesc,
        ) -> SEXP,
    >,
    pub useGroup:
        ::std::option::Option<unsafe extern "C" fn(ref_: SEXP, trans: SEXP, dd: pDevDesc)>,
    pub releaseGroup: ::std::option::Option<unsafe extern "C" fn(ref_: SEXP, dd: pDevDesc)>,
    pub stroke:
        ::std::option::Option<unsafe extern "C" fn(path: SEXP, gc: pGEcontext, dd: pDevDesc)>,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(path: SEXP, rule: ::std::os::raw::c_int, gc: pGEcontext, dd: pDevDesc),
    >,
    pub fillStroke: ::std::option::Option<
        unsafe extern "C" fn(path: SEXP, rule: ::std::os::raw::c_int, gc: pGEcontext, dd: pDevDesc),
    >,
    pub capabilities: ::std::option::Option<unsafe extern "C" fn(cap: SEXP) -> SEXP>,
    pub glyph: ::std::option::Option<
        unsafe extern "C" fn(
            n: ::std::os::raw::c_int,
            glyphs: *mut ::std::os::raw::c_int,
            x: *mut f64,
            y: *mut f64,
            font: SEXP,
            size: f64,
            colour: ::std::os::raw::c_int,
            rot: f64,
            dd: pDevDesc,
        ),
    >,
    #[doc = "Area for future expansion.\nBy zeroing this, devices are more likely to work if loaded\ninto a later version of R than that they were compiled under."]
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GESystemDesc {
    #[doc = "An array of information about each graphics system that\n has registered with the graphics engine.\n This is used to store graphics state for each graphics\n system on each device."]
    pub systemSpecific: *mut ::std::os::raw::c_void,
    #[doc = "An array of function pointers, one per graphics system that\n has registered with the graphics engine.\n\n system_Callback is called when the graphics engine wants\n to give a graphics system the chance to play with its\n device-specific information (stored in systemSpecific)\n There are two parameters:  an \"event\" to tell the graphics\n system why the graphics engine has called this function,\n and the systemSpecific pointer.  The graphics engine\n has to pass the systemSpecific pointer because only\n the graphics engine will know what array index to use."]
    pub callback: GEcallback,
}
#[repr(C)]
pub struct _GEDevDesc {
    #[doc = "Stuff that the devices can see (and modify).\n All detailed in GraphicsDevice.h"]
    pub dev: pDevDesc,
    #[doc = "toggle for display list status"]
    pub displayListOn: Rboolean,
    #[doc = "display list"]
    pub displayList: SEXP,
    #[doc = "A pointer to the end of the display list\nto avoid traversing pairlists"]
    pub DLlastElt: SEXP,
    #[doc = "The last element of the display list\n just prior to when the display list\n was last initialised"]
    pub savedSnapshot: SEXP,
    #[doc = "Has the device received any output?"]
    pub dirty: Rboolean,
    #[doc = "Should a graphics call be stored\n on the display list?\n Set to FALSE by do_recordGraphics,\n do_dotcallgr, and do_Externalgr\n so that nested calls are not\n recorded on the display list"]
    pub recordGraphics: Rboolean,
    #[doc = "Stuff about the device that only graphics systems see.\n The graphics engine has no idea what is in here.\n Used by graphics systems to store system state per device."]
    pub gesd: [*mut GESystemDesc; 24usize],
    #[doc = "per-device setting for 'ask' (use NewFrameConfirm)"]
    pub ask: Rboolean,
    #[doc = "Is a device appending a path ?"]
    pub appending: Rboolean,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const R_GE_definitions: u32 = 13;
pub const R_GE_deviceClip: u32 = 14;
pub const R_GE_group: u32 = 15;
pub const R_GE_glyphs: u32 = 16;
pub const R_GE_version: u32 = 16;
pub const MAX_GRAPHICS_SYSTEMS: u32 = 24;
pub const R_USE_PROTOTYPES: u32 = 1;
pub const leftButton: u32 = 1;
pub const middleButton: u32 = 2;
pub const rightButton: u32 = 4;
pub const LTY_BLANK: i32 = -1;
pub const LTY_SOLID: u32 = 0;
pub const LTY_DASHED: u32 = 68;
pub const LTY_DOTTED: u32 = 49;
pub const LTY_DOTDASH: u32 = 13361;
pub const LTY_LONGDASH: u32 = 55;
pub const LTY_TWODASH: u32 = 9762;
pub const DEG2RAD: f64 = 0.017453292519943295;
pub const R_GE_linearGradientPattern: u32 = 1;
pub const R_GE_radialGradientPattern: u32 = 2;
pub const R_GE_tilingPattern: u32 = 3;
pub const R_GE_patternExtendPad: u32 = 1;
pub const R_GE_patternExtendRepeat: u32 = 2;
pub const R_GE_patternExtendReflect: u32 = 3;
pub const R_GE_patternExtendNone: u32 = 4;
pub const R_GE_compositeClear: u32 = 1;
pub const R_GE_compositeSource: u32 = 2;
pub const R_GE_compositeOver: u32 = 3;
pub const R_GE_compositeIn: u32 = 4;
pub const R_GE_compositeOut: u32 = 5;
pub const R_GE_compositeAtop: u32 = 6;
pub const R_GE_compositeDest: u32 = 7;
pub const R_GE_compositeDestOver: u32 = 8;
pub const R_GE_compositeDestIn: u32 = 9;
pub const R_GE_compositeDestOut: u32 = 10;
pub const R_GE_compositeDestAtop: u32 = 11;
pub const R_GE_compositeXor: u32 = 12;
pub const R_GE_compositeAdd: u32 = 13;
pub const R_GE_compositeSaturate: u32 = 14;
pub const R_GE_compositeMultiply: u32 = 15;
pub const R_GE_compositeScreen: u32 = 16;
pub const R_GE_compositeOverlay: u32 = 17;
pub const R_GE_compositeDarken: u32 = 18;
pub const R_GE_compositeLighten: u32 = 19;
pub const R_GE_compositeColorDodge: u32 = 20;
pub const R_GE_compositeColorBurn: u32 = 21;
pub const R_GE_compositeHardLight: u32 = 22;
pub const R_GE_compositeSoftLight: u32 = 23;
pub const R_GE_compositeDifference: u32 = 24;
pub const R_GE_compositeExclusion: u32 = 25;
pub const R_GE_nonZeroWindingRule: u32 = 1;
pub const R_GE_evenOddRule: u32 = 2;
pub const R_GE_alphaMask: u32 = 1;
pub const R_GE_luminanceMask: u32 = 2;
pub const R_GE_capability_semiTransparency: u32 = 0;
pub const R_GE_capability_transparentBackground: u32 = 1;
pub const R_GE_capability_rasterImage: u32 = 2;
pub const R_GE_capability_capture: u32 = 3;
pub const R_GE_capability_locator: u32 = 4;
pub const R_GE_capability_events: u32 = 5;
pub const R_GE_capability_patterns: u32 = 6;
pub const R_GE_capability_clippingPaths: u32 = 7;
pub const R_GE_capability_masks: u32 = 8;
pub const R_GE_capability_compositing: u32 = 9;
pub const R_GE_capability_transformations: u32 = 10;
pub const R_GE_capability_paths: u32 = 11;
pub const R_GE_capability_glyphs: u32 = 12;
pub const R_GE_text_style_normal: u32 = 1;
pub const R_GE_text_style_italic: u32 = 2;
pub const R_GE_text_style_oblique: u32 = 3;
#[repr(i32)]
#[doc = "The graphics engine will only accept locations and dimensions\n in native device coordinates, but it provides the following functions\n for converting between a couple of simple alternative coordinate\n systems and device coordinates:\n    DEVICE = native units of the device\n    NDC = Normalised device coordinates\n    INCHES = inches (!)\n    CM = centimetres (!!)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GEUnit {
    #[doc = "native device coordinates (rasters)"]
    GE_DEVICE = 0,
    #[doc = "normalised device coordinates x=(0,1), y=(0,1)"]
    GE_NDC = 1,
    GE_INCHES = 2,
    GE_CM = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GEevent {
    #[doc = "In response to this event, the registered graphics system\n should allocate and initialise the systemSpecific structure\n\n Should return R_NilValue on failure so that engine\n can tidy up memory allocation"]
    GE_InitState = 0,
    #[doc = "This event gives the registered system a chance to undo\n anything done in the initialisation."]
    GE_FinaliseState = 1,
    #[doc = "This is sent by the graphics engine prior to initialising\n the display list.  It give the graphics system the chance\n to squirrel away information it will need for redrawing the\n the display list"]
    GE_SaveState = 2,
    #[doc = "This is sent by the graphics engine prior to replaying the\n display list.  It gives the graphics system the chance to\n restore any information it saved on the GE_SaveState event"]
    GE_RestoreState = 6,
    #[doc = "Copy system state information to the current device.\n This is used when copying graphics from one device to another\n so all the graphics system needs to do is to copy across\n the bits required for the display list to draw faithfully\n on the new device."]
    GE_CopyState = 3,
    #[doc = "Create a snapshot of the system state that is sufficient\n for the current \"image\" to be reproduced"]
    GE_SaveSnapshotState = 4,
    #[doc = "Restore the system state that is saved by GE_SaveSnapshotState"]
    GE_RestoreSnapshotState = 5,
    #[doc = "When replaying the display list, the graphics engine\n checks, after each replayed action, that the action\n produced valid output.  This is the graphics system's\n chance to say that the output is crap (in which case the\n graphics engine will abort the display list replay)."]
    GE_CheckPlot = 7,
    #[doc = "The device wants to scale the current pointsize\n (for scaling an image)\n This is not a nice general solution, but a quick fix for\n the Windows device."]
    GE_ScalePS = 8,
}
#[repr(i32)]
#[doc = "Some line end/join constants"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum R_GE_lineend {
    GE_ROUND_CAP = 1,
    GE_BUTT_CAP = 2,
    GE_SQUARE_CAP = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum R_GE_linejoin {
    GE_ROUND_JOIN = 1,
    GE_MITRE_JOIN = 2,
    GE_BEVEL_JOIN = 3,
}
#[repr(i32)]
#[doc = "These give the indices of some known keys"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum R_KeyName {
    knUNKNOWN = -1,
    knLEFT = 0,
    knUP = 1,
    knRIGHT = 2,
    knDOWN = 3,
    knF1 = 4,
    knF2 = 5,
    knF3 = 6,
    knF4 = 7,
    knF5 = 8,
    knF6 = 9,
    knF7 = 10,
    knF8 = 11,
    knF9 = 12,
    knF10 = 13,
    knF11 = 14,
    knF12 = 15,
    knPGUP = 16,
    knPGDN = 17,
    knEND = 18,
    knHOME = 19,
    knINS = 20,
    knDEL = 21,
}
#[repr(i32)]
#[doc = "These are the three possible mouse events"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum R_MouseEvent {
    meMouseDown = 0,
    meMouseUp = 1,
    meMouseMove = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
}
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
    pub fn __security_init_cookie();
    pub fn __security_check_cookie(_StackCookie: usize);
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
    pub static mut __security_cookie: usize;
    pub fn _invalid_parameter_noinfo();
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
    pub fn _fgetwchar() -> wint_t;
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
    pub fn getwchar() -> wint_t;
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn putwchar(_Character: wchar_t) -> wint_t;
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
    pub fn _wperror(_ErrorMessage: *const wchar_t);
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
    pub fn clearerr(_Stream: *mut FILE);
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fcloseall() -> ::std::os::raw::c_int;
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fgetchar() -> ::std::os::raw::c_int;
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _flushall() -> ::std::os::raw::c_int;
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn rewind(_Stream: *mut FILE);
    pub fn _rmtmp() -> ::std::os::raw::c_int;
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _lock_file(_Stream: *mut FILE);
    pub fn _unlock_file(_Stream: *mut FILE);
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn fcloseall() -> ::std::os::raw::c_int;
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn fgetchar() -> ::std::os::raw::c_int;
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn flushall() -> ::std::os::raw::c_int;
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn rmtmp() -> ::std::os::raw::c_int;
    pub static _HUGE: f64;
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
    pub static _Denorm_C: _float_const;
    pub static _Inf_C: _float_const;
    pub static _Nan_C: _float_const;
    pub static _Snan_C: _float_const;
    pub static _Hugeval_C: _float_const;
    pub static _FDenorm_C: _float_const;
    pub static _FInf_C: _float_const;
    pub static _FNan_C: _float_const;
    pub static _FSnan_C: _float_const;
    pub static _LDenorm_C: _float_const;
    pub static _LInf_C: _float_const;
    pub static _LNan_C: _float_const;
    pub static _LSnan_C: _float_const;
    pub static _Eps_C: _float_const;
    pub static _Rteps_C: _float_const;
    pub static _FEps_C: _float_const;
    pub static _FRteps_C: _float_const;
    pub static _LEps_C: _float_const;
    pub static _LRteps_C: _float_const;
    pub static _Zero_C: f64;
    pub static _Xbig_C: f64;
    pub static _FZero_C: f32;
    pub static _FXbig_C: f32;
    pub static _LZero_C: f64;
    pub static _LXbig_C: f64;
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
    pub fn acos(_X: f64) -> f64;
    pub fn asin(_X: f64) -> f64;
    pub fn atan(_X: f64) -> f64;
    pub fn atan2(_Y: f64, _X: f64) -> f64;
    pub fn cos(_X: f64) -> f64;
    pub fn cosh(_X: f64) -> f64;
    pub fn exp(_X: f64) -> f64;
    pub fn fabs(_X: f64) -> f64;
    pub fn fmod(_X: f64, _Y: f64) -> f64;
    pub fn log(_X: f64) -> f64;
    pub fn log10(_X: f64) -> f64;
    pub fn pow(_X: f64, _Y: f64) -> f64;
    pub fn sin(_X: f64) -> f64;
    pub fn sinh(_X: f64) -> f64;
    pub fn sqrt(_X: f64) -> f64;
    pub fn tan(_X: f64) -> f64;
    pub fn tanh(_X: f64) -> f64;
    pub fn acosh(_X: f64) -> f64;
    pub fn asinh(_X: f64) -> f64;
    pub fn atanh(_X: f64) -> f64;
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
    pub fn _cabs(_Complex_value: _complex) -> f64;
    pub fn cbrt(_X: f64) -> f64;
    pub fn ceil(_X: f64) -> f64;
    pub fn _chgsign(_X: f64) -> f64;
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
    pub fn erf(_X: f64) -> f64;
    pub fn erfc(_X: f64) -> f64;
    pub fn exp2(_X: f64) -> f64;
    pub fn expm1(_X: f64) -> f64;
    pub fn fdim(_X: f64, _Y: f64) -> f64;
    pub fn floor(_X: f64) -> f64;
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
    pub fn fmax(_X: f64, _Y: f64) -> f64;
    pub fn fmin(_X: f64, _Y: f64) -> f64;
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
    pub fn hypot(_X: f64, _Y: f64) -> f64;
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn lgamma(_X: f64) -> f64;
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn log1p(_X: f64) -> f64;
    pub fn log2(_X: f64) -> f64;
    pub fn logb(_X: f64) -> f64;
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
    pub fn nearbyint(_X: f64) -> f64;
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
    pub fn remainder(_X: f64, _Y: f64) -> f64;
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
    pub fn rint(_X: f64) -> f64;
    pub fn round(_X: f64) -> f64;
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn tgamma(_X: f64) -> f64;
    pub fn trunc(_X: f64) -> f64;
    pub fn _j0(_X: f64) -> f64;
    pub fn _j1(_X: f64) -> f64;
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn _y0(_X: f64) -> f64;
    pub fn _y1(_X: f64) -> f64;
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn acoshf(_X: f32) -> f32;
    pub fn asinhf(_X: f32) -> f32;
    pub fn atanhf(_X: f32) -> f32;
    pub fn cbrtf(_X: f32) -> f32;
    pub fn _chgsignf(_X: f32) -> f32;
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
    pub fn erff(_X: f32) -> f32;
    pub fn erfcf(_X: f32) -> f32;
    pub fn expm1f(_X: f32) -> f32;
    pub fn exp2f(_X: f32) -> f32;
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
    pub fn fminf(_X: f32, _Y: f32) -> f32;
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
    pub fn lgammaf(_X: f32) -> f32;
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
    pub fn log1pf(_X: f32) -> f32;
    pub fn log2f(_X: f32) -> f32;
    pub fn logbf(_X: f32) -> f32;
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
    pub fn nearbyintf(_X: f32) -> f32;
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
    pub fn rintf(_X: f32) -> f32;
    pub fn roundf(_X: f32) -> f32;
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
    pub fn tgammaf(_X: f32) -> f32;
    pub fn truncf(_X: f32) -> f32;
    pub fn _logbf(_X: f32) -> f32;
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
    pub fn acosf(_X: f32) -> f32;
    pub fn asinf(_X: f32) -> f32;
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
    pub fn atanf(_X: f32) -> f32;
    pub fn ceilf(_X: f32) -> f32;
    pub fn cosf(_X: f32) -> f32;
    pub fn coshf(_X: f32) -> f32;
    pub fn expf(_X: f32) -> f32;
    pub fn floorf(_X: f32) -> f32;
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
    pub fn log10f(_X: f32) -> f32;
    pub fn logf(_X: f32) -> f32;
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
    pub fn powf(_X: f32, _Y: f32) -> f32;
    pub fn sinf(_X: f32) -> f32;
    pub fn sinhf(_X: f32) -> f32;
    pub fn sqrtf(_X: f32) -> f32;
    pub fn tanf(_X: f32) -> f32;
    pub fn tanhf(_X: f32) -> f32;
    pub fn acoshl(_X: f64) -> f64;
    pub fn asinhl(_X: f64) -> f64;
    pub fn atanhl(_X: f64) -> f64;
    pub fn cbrtl(_X: f64) -> f64;
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
    pub fn erfl(_X: f64) -> f64;
    pub fn erfcl(_X: f64) -> f64;
    pub fn exp2l(_X: f64) -> f64;
    pub fn expm1l(_X: f64) -> f64;
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
    pub fn fminl(_X: f64, _Y: f64) -> f64;
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
    pub fn lgammal(_X: f64) -> f64;
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
    pub fn log1pl(_X: f64) -> f64;
    pub fn log2l(_X: f64) -> f64;
    pub fn logbl(_X: f64) -> f64;
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
    pub fn nearbyintl(_X: f64) -> f64;
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
    pub fn rintl(_X: f64) -> f64;
    pub fn roundl(_X: f64) -> f64;
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    pub fn tgammal(_X: f64) -> f64;
    pub fn truncl(_X: f64) -> f64;
    pub static mut HUGE: f64;
    pub fn j0(_X: f64) -> f64;
    pub fn j1(_X: f64) -> f64;
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn y0(_X: f64) -> f64;
    pub fn y1(_X: f64) -> f64;
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    pub fn R_GE_getVersion() -> ::std::os::raw::c_int;
    pub fn R_GE_checkVersionOrDie(version: ::std::os::raw::c_int);
    pub fn Rf_ndevNumber(arg1: pDevDesc) -> ::std::os::raw::c_int;
    pub fn Rf_NumDevices() -> ::std::os::raw::c_int;
    #[doc = "Check for an available device slot"]
    pub fn R_CheckDeviceAvailable();
    pub fn R_CheckDeviceAvailableBool() -> Rboolean;
    pub fn Rf_curDevice() -> ::std::os::raw::c_int;
    pub fn Rf_nextDevice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn Rf_prevDevice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn Rf_selectDevice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn Rf_killDevice(arg1: ::std::os::raw::c_int);
    pub fn Rf_NoDevices() -> ::std::os::raw::c_int;
    pub fn Rf_NewFrameConfirm(arg1: pDevDesc);
    pub fn Rf_doMouseEvent(
        dd: pDevDesc,
        event: R_MouseEvent,
        buttons: ::std::os::raw::c_int,
        x: f64,
        y: f64,
    );
    pub fn Rf_doKeybd(dd: pDevDesc, rkey: R_KeyName, keyname: *const ::std::os::raw::c_char);
    pub fn Rf_doIdle(dd: pDevDesc);
    pub fn Rf_doesIdle(dd: pDevDesc) -> Rboolean;
    pub static mut R_interrupts_suspended: Rboolean;
    pub static mut R_interrupts_pending: ::std::os::raw::c_int;
    pub fn Rf_onintr();
    pub static mut mbcslocale: Rboolean;
    pub fn Rf_AdobeSymbol2utf8(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
        nwork: usize,
        usePUA: Rboolean,
    ) -> *mut ::std::os::raw::c_void;
    pub fn Rf_utf8toAdobeSymbol(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn Rf_utf8Toutf8NoPUA(in_: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn Rf_utf8ToLatin1AdobeSymbol2utf8(
        in_: *const ::std::os::raw::c_char,
        usePUA: Rboolean,
    ) -> *const ::std::os::raw::c_char;
    #[doc = "Translates Unicode point to UTF-8"]
    pub fn Rf_ucstoutf8(s: *mut ::std::os::raw::c_char, c: ::std::os::raw::c_uint) -> usize;
    pub fn Rf_desc2GEDesc(dd: pDevDesc) -> pGEDevDesc;
    pub fn GEdeviceNumber(arg1: pGEDevDesc) -> ::std::os::raw::c_int;
    pub fn GEgetDevice(arg1: ::std::os::raw::c_int) -> pGEDevDesc;
    pub fn GEaddDevice(arg1: pGEDevDesc);
    pub fn GEaddDevice2(arg1: pGEDevDesc, arg2: *const ::std::os::raw::c_char);
    pub fn GEaddDevice2f(
        arg1: pGEDevDesc,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    );
    pub fn GEkillDevice(arg1: pGEDevDesc);
    pub fn GEcreateDevDesc(dev: pDevDesc) -> pGEDevDesc;
    pub fn GEdestroyDevDesc(dd: pGEDevDesc);
    pub fn GEsystemState(
        dd: pGEDevDesc,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn GEregisterWithDevice(dd: pGEDevDesc);
    pub fn GEregisterSystem(callback: GEcallback, systemRegisterIndex: *mut ::std::os::raw::c_int);
    pub fn GEunregisterSystem(registerIndex: ::std::os::raw::c_int);
    pub fn GEhandleEvent(event: GEevent, dev: pDevDesc, data: SEXP) -> SEXP;
    pub fn GEfromDeviceX(value: f64, to: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEtoDeviceX(value: f64, from: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEfromDeviceY(value: f64, to: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEtoDeviceY(value: f64, from: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEfromDeviceWidth(value: f64, to: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEtoDeviceWidth(value: f64, from: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEfromDeviceHeight(value: f64, to: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn GEtoDeviceHeight(value: f64, from: GEUnit, dd: pGEDevDesc) -> f64;
    pub fn Rf_RGBpar(arg1: SEXP, arg2: ::std::os::raw::c_int) -> rcolor;
    pub fn Rf_RGBpar3(arg1: SEXP, arg2: ::std::os::raw::c_int, arg3: rcolor) -> rcolor;
    pub fn Rf_col2name(col: rcolor) -> *const ::std::os::raw::c_char;
    #[doc = "Convert either a name or a #RRGGBB`[AA]` string to internal.\nBecause people were using it, it also converts \"1\", \"2\" ...\nto a colour in the palette, and \"0\" to transparent white."]
    pub fn R_GE_str2col(s: *const ::std::os::raw::c_char) -> rcolor;
    pub fn GE_LENDpar(value: SEXP, ind: ::std::os::raw::c_int) -> R_GE_lineend;
    pub fn GE_LENDget(lend: R_GE_lineend) -> SEXP;
    pub fn GE_LJOINpar(value: SEXP, ind: ::std::os::raw::c_int) -> R_GE_linejoin;
    pub fn GE_LJOINget(ljoin: R_GE_linejoin) -> SEXP;
    pub fn GESetClip(x1: f64, y1: f64, x2: f64, y2: f64, dd: pGEDevDesc);
    pub fn GENewPage(gc: pGEcontext, dd: pGEDevDesc);
    pub fn GELine(x1: f64, y1: f64, x2: f64, y2: f64, gc: pGEcontext, dd: pGEDevDesc);
    pub fn GEPolyline(
        n: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GEPolygon(
        n: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GEXspline(
        n: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        s: *mut f64,
        open: Rboolean,
        repEnds: Rboolean,
        draw: Rboolean,
        gc: pGEcontext,
        dd: pGEDevDesc,
    ) -> SEXP;
    pub fn GECircle(x: f64, y: f64, radius: f64, gc: pGEcontext, dd: pGEDevDesc);
    pub fn GERect(x0: f64, y0: f64, x1: f64, y1: f64, gc: pGEcontext, dd: pGEDevDesc);
    pub fn GEPath(
        x: *mut f64,
        y: *mut f64,
        npoly: ::std::os::raw::c_int,
        nper: *mut ::std::os::raw::c_int,
        winding: Rboolean,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GERaster(
        raster: *mut ::std::os::raw::c_uint,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        x: f64,
        y: f64,
        width: f64,
        height: f64,
        angle: f64,
        interpolate: Rboolean,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GECap(dd: pGEDevDesc) -> SEXP;
    pub fn GEText(
        x: f64,
        y: f64,
        str_: *const ::std::os::raw::c_char,
        enc: cetype_t,
        xc: f64,
        yc: f64,
        rot: f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GEMode(mode: ::std::os::raw::c_int, dd: pGEDevDesc);
    pub fn GESymbol(
        x: f64,
        y: f64,
        pch: ::std::os::raw::c_int,
        size: f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GEPretty(lo: *mut f64, up: *mut f64, ndiv: *mut ::std::os::raw::c_int);
    pub fn GEMetricInfo(
        c: ::std::os::raw::c_int,
        gc: pGEcontext,
        ascent: *mut f64,
        descent: *mut f64,
        width: *mut f64,
        dd: pGEDevDesc,
    );
    pub fn GEStrWidth(
        str_: *const ::std::os::raw::c_char,
        enc: cetype_t,
        gc: pGEcontext,
        dd: pGEDevDesc,
    ) -> f64;
    pub fn GEStrHeight(
        str_: *const ::std::os::raw::c_char,
        enc: cetype_t,
        gc: pGEcontext,
        dd: pGEDevDesc,
    ) -> f64;
    pub fn GEStrMetric(
        str_: *const ::std::os::raw::c_char,
        enc: cetype_t,
        gc: pGEcontext,
        ascent: *mut f64,
        descent: *mut f64,
        width: *mut f64,
        dd: pGEDevDesc,
    );
    pub fn GEstring_to_pch(pch: SEXP) -> ::std::os::raw::c_int;
    #[doc = "-------------------------------------------------------------------\n\n  LINE TEXTURE CODE is concerned with the internals of R\n  line texture representation."]
    pub fn GE_LTYpar(arg1: SEXP, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
    pub fn GE_LTYget(arg1: ::std::os::raw::c_uint) -> SEXP;
    #[doc = "Raster operations"]
    pub fn R_GE_rasterScale(
        sraster: *mut ::std::os::raw::c_uint,
        sw: ::std::os::raw::c_int,
        sh: ::std::os::raw::c_int,
        draster: *mut ::std::os::raw::c_uint,
        dw: ::std::os::raw::c_int,
        dh: ::std::os::raw::c_int,
    );
    pub fn R_GE_rasterInterpolate(
        sraster: *mut ::std::os::raw::c_uint,
        sw: ::std::os::raw::c_int,
        sh: ::std::os::raw::c_int,
        draster: *mut ::std::os::raw::c_uint,
        dw: ::std::os::raw::c_int,
        dh: ::std::os::raw::c_int,
    );
    pub fn R_GE_rasterRotatedSize(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        angle: f64,
        wnew: *mut ::std::os::raw::c_int,
        hnew: *mut ::std::os::raw::c_int,
    );
    pub fn R_GE_rasterRotatedOffset(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        angle: f64,
        botleft: ::std::os::raw::c_int,
        xoff: *mut f64,
        yoff: *mut f64,
    );
    pub fn R_GE_rasterResizeForRotation(
        sraster: *mut ::std::os::raw::c_uint,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        newRaster: *mut ::std::os::raw::c_uint,
        wnew: ::std::os::raw::c_int,
        hnew: ::std::os::raw::c_int,
        gc: pGEcontext,
    );
    pub fn R_GE_rasterRotate(
        sraster: *mut ::std::os::raw::c_uint,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        angle: f64,
        draster: *mut ::std::os::raw::c_uint,
        gc: pGEcontext,
        perPixelAlpha: Rboolean,
    );
    #[doc = "From plotmath.c"]
    pub fn GEExpressionWidth(expr: SEXP, gc: pGEcontext, dd: pGEDevDesc) -> f64;
    pub fn GEExpressionHeight(expr: SEXP, gc: pGEcontext, dd: pGEDevDesc) -> f64;
    pub fn GEExpressionMetric(
        expr: SEXP,
        gc: pGEcontext,
        ascent: *mut f64,
        descent: *mut f64,
        width: *mut f64,
        dd: pGEDevDesc,
    );
    pub fn GEMathText(
        x: f64,
        y: f64,
        expr: SEXP,
        xc: f64,
        yc: f64,
        rot: f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    #[doc = "From plot3d.c : used in package clines"]
    pub fn GEcontourLines(
        x: *mut f64,
        nx: ::std::os::raw::c_int,
        y: *mut f64,
        ny: ::std::os::raw::c_int,
        z: *mut f64,
        levels: *mut f64,
        nl: ::std::os::raw::c_int,
    ) -> SEXP;
    #[doc = "From vfonts.c"]
    pub fn R_GE_VStrWidth(
        s: *const ::std::os::raw::c_char,
        enc: cetype_t,
        gc: pGEcontext,
        dd: pGEDevDesc,
    ) -> f64;
    pub fn R_GE_VStrHeight(
        s: *const ::std::os::raw::c_char,
        enc: cetype_t,
        gc: pGEcontext,
        dd: pGEDevDesc,
    ) -> f64;
    pub fn R_GE_VText(
        x: f64,
        y: f64,
        s: *const ::std::os::raw::c_char,
        enc: cetype_t,
        x_justify: f64,
        y_justify: f64,
        rotation: f64,
        gc: pGEcontext,
        dd: pGEDevDesc,
    );
    pub fn GEcurrentDevice() -> pGEDevDesc;
    pub fn GEdeviceDirty(dd: pGEDevDesc) -> Rboolean;
    pub fn GEdirtyDevice(dd: pGEDevDesc);
    pub fn GEcheckState(dd: pGEDevDesc) -> Rboolean;
    pub fn GErecording(call: SEXP, dd: pGEDevDesc) -> Rboolean;
    pub fn GErecordGraphicOperation(op: SEXP, args: SEXP, dd: pGEDevDesc);
    pub fn GEinitDisplayList(dd: pGEDevDesc);
    pub fn GEplayDisplayList(dd: pGEDevDesc);
    pub fn GEcopyDisplayList(fromDevice: ::std::os::raw::c_int);
    pub fn GEcreateSnapshot(dd: pGEDevDesc) -> SEXP;
    pub fn GEplaySnapshot(snapshot: SEXP, dd: pGEDevDesc);
    pub fn GEonExit();
    pub fn GEnullDevice();
    pub fn Rf_CreateAtVector(
        axp: *mut f64,
        usr: *const f64,
        nint: ::std::os::raw::c_int,
        logflag: Rboolean,
    ) -> SEXP;
    pub fn Rf_GAxisPars(
        min: *mut f64,
        max: *mut f64,
        n: *mut ::std::os::raw::c_int,
        log: Rboolean,
        axis: ::std::os::raw::c_int,
    );
    #[doc = "Patterns - from ../../main/patterns.c"]
    pub fn R_GE_isPattern(x: SEXP) -> Rboolean;
    pub fn R_GE_patternType(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_linearGradientX1(pattern: SEXP) -> f64;
    pub fn R_GE_linearGradientY1(pattern: SEXP) -> f64;
    pub fn R_GE_linearGradientX2(pattern: SEXP) -> f64;
    pub fn R_GE_linearGradientY2(pattern: SEXP) -> f64;
    pub fn R_GE_linearGradientNumStops(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_linearGradientStop(pattern: SEXP, i: ::std::os::raw::c_int) -> f64;
    pub fn R_GE_linearGradientColour(pattern: SEXP, i: ::std::os::raw::c_int) -> rcolor;
    pub fn R_GE_linearGradientExtend(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_radialGradientCX1(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientCY1(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientR1(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientCX2(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientCY2(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientR2(pattern: SEXP) -> f64;
    pub fn R_GE_radialGradientNumStops(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_radialGradientStop(pattern: SEXP, i: ::std::os::raw::c_int) -> f64;
    pub fn R_GE_radialGradientColour(pattern: SEXP, i: ::std::os::raw::c_int) -> rcolor;
    pub fn R_GE_radialGradientExtend(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_tilingPatternFunction(pattern: SEXP) -> SEXP;
    pub fn R_GE_tilingPatternX(pattern: SEXP) -> f64;
    pub fn R_GE_tilingPatternY(pattern: SEXP) -> f64;
    pub fn R_GE_tilingPatternWidth(pattern: SEXP) -> f64;
    pub fn R_GE_tilingPatternHeight(pattern: SEXP) -> f64;
    pub fn R_GE_tilingPatternExtend(pattern: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_clipPathFillRule(path: SEXP) -> ::std::os::raw::c_int;
    pub fn GEStroke(path: SEXP, gc: pGEcontext, dd: pGEDevDesc);
    pub fn GEFill(path: SEXP, rule: ::std::os::raw::c_int, gc: pGEcontext, dd: pGEDevDesc);
    pub fn GEFillStroke(path: SEXP, rule: ::std::os::raw::c_int, gc: pGEcontext, dd: pGEDevDesc);
    pub fn R_GE_maskType(mask: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_glyphInfoGlyphs(glyphInfo: SEXP) -> SEXP;
    pub fn R_GE_glyphInfoFonts(glyphInfo: SEXP) -> SEXP;
    pub fn R_GE_glyphID(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphX(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphY(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphFont(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphSize(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphColour(glyphs: SEXP) -> SEXP;
    pub fn R_GE_glyphFontFile(glyphFont: SEXP) -> *const ::std::os::raw::c_char;
    pub fn R_GE_glyphFontIndex(glyphFont: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_glyphFontFamily(glyphFont: SEXP) -> *const ::std::os::raw::c_char;
    pub fn R_GE_glyphFontWeight(glyphFont: SEXP) -> f64;
    pub fn R_GE_glyphFontStyle(glyphFont: SEXP) -> ::std::os::raw::c_int;
    pub fn R_GE_glyphFontPSname(glyphFont: SEXP) -> *const ::std::os::raw::c_char;
    pub fn GEGlyph(
        n: ::std::os::raw::c_int,
        glyphs: *mut ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        font: SEXP,
        size: f64,
        colour: ::std::os::raw::c_int,
        rot: f64,
        dd: pGEDevDesc,
    );
}
