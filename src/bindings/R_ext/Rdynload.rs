/* automatically generated by rust-bindgen 0.66.1 */

pub const SINGLESXP: u32 = 302;
pub const Rboolean_FALSE: Rboolean = 0;
pub const Rboolean_TRUE: Rboolean = 1;
pub type Rboolean = ::std::os::raw::c_int;
pub type DL_FUNC = ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
pub type R_NativePrimitiveArgType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct R_CMethodDef {
    pub name: *const ::std::os::raw::c_char,
    pub fun: DL_FUNC,
    pub numArgs: ::std::os::raw::c_int,
    pub types: *mut R_NativePrimitiveArgType,
}
#[test]
fn bindgen_test_layout_R_CMethodDef() {
    const UNINIT: ::std::mem::MaybeUninit<R_CMethodDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<R_CMethodDef>(),
        32usize,
        concat!("Size of: ", stringify!(R_CMethodDef))
    );
    assert_eq!(
        ::std::mem::align_of::<R_CMethodDef>(),
        8usize,
        concat!("Alignment of ", stringify!(R_CMethodDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CMethodDef),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fun) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CMethodDef),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CMethodDef),
            "::",
            stringify!(numArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CMethodDef),
            "::",
            stringify!(types)
        )
    );
}
pub type R_FortranMethodDef = R_CMethodDef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct R_CallMethodDef {
    pub name: *const ::std::os::raw::c_char,
    pub fun: DL_FUNC,
    pub numArgs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_R_CallMethodDef() {
    const UNINIT: ::std::mem::MaybeUninit<R_CallMethodDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<R_CallMethodDef>(),
        24usize,
        concat!("Size of: ", stringify!(R_CallMethodDef))
    );
    assert_eq!(
        ::std::mem::align_of::<R_CallMethodDef>(),
        8usize,
        concat!("Alignment of ", stringify!(R_CallMethodDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CallMethodDef),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fun) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CallMethodDef),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(R_CallMethodDef),
            "::",
            stringify!(numArgs)
        )
    );
}
pub type R_ExternalMethodDef = R_CallMethodDef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DllInfo {
    _unused: [u8; 0],
}
pub type DllInfo = _DllInfo;
extern "C" {
    pub fn R_registerRoutines(
        info: *mut DllInfo,
        croutines: *const R_CMethodDef,
        callRoutines: *const R_CallMethodDef,
        fortranRoutines: *const R_FortranMethodDef,
        externalRoutines: *const R_ExternalMethodDef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn R_useDynamicSymbols(info: *mut DllInfo, value: Rboolean) -> Rboolean;
}
extern "C" {
    pub fn R_forceSymbols(info: *mut DllInfo, value: Rboolean) -> Rboolean;
}
extern "C" {
    pub fn R_getDllInfo(name: *const ::std::os::raw::c_char) -> *mut DllInfo;
}
extern "C" {
    pub fn R_getEmbeddingDllInfo() -> *mut DllInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rf_RegisteredNativeSymbol {
    _unused: [u8; 0],
}
pub type R_RegisteredNativeSymbol = Rf_RegisteredNativeSymbol;
pub const NativeSymbolType_R_ANY_SYM: NativeSymbolType = 0;
pub const NativeSymbolType_R_C_SYM: NativeSymbolType = 1;
pub const NativeSymbolType_R_CALL_SYM: NativeSymbolType = 2;
pub const NativeSymbolType_R_FORTRAN_SYM: NativeSymbolType = 3;
pub const NativeSymbolType_R_EXTERNAL_SYM: NativeSymbolType = 4;
pub type NativeSymbolType = ::std::os::raw::c_int;
extern "C" {
    pub fn R_FindSymbol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        symbol: *mut R_RegisteredNativeSymbol,
    ) -> DL_FUNC;
}
extern "C" {
    pub fn R_RegisterCCallable(
        package: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        fptr: DL_FUNC,
    );
}
extern "C" {
    pub fn R_GetCCallable(
        package: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> DL_FUNC;
}
